性能优化分为构建性能、传输性能、运行性能，构建工具只能优化前两者

**构建性能**指的是打包时间

**传输性能**指的是打包后的js代码传输到浏览器的时间

**运行性能**指的是js代码在浏览器端的运行速度，取决于我们写的代码，与构建工具无关



# vite打包原理

npm run build运行vite打包时vite自身是没有打包构建功能的，通过内置rollup完成

vite打包配置通过build进行配置，其中rollupOptions配置参考rollup文档



# build配置中的lib模式、rollupOptions模式

**lib 模式：**

专门用于构建库（library），而不是应用

特点：

- 不会进行代码分割（code splitting）
- 不会注入 HTML
- 外部化所有依赖（默认）
- 生成适合发布到 npm 的包

**rollupOptions模式**

构建完整的 web 应用

特点：

- 支持代码分割
- 可以有多个入口
- 生成 HTML 文件
- 依赖会被打包进来



# chunk

rollup打包的最小单位是chunk，一个chunk对应一个输出文件

## 默认分割策略

**入口块**

```js
input:{
    main:'src/main.js',
    admin:'src/admin.js'
}
```

每个入口文件及其同步依赖生成独立的chunk，其中key为chunk名

**动态块**

```js
const module=await import('./dynamic-module.js')
```

动态导入import的模块创建独立的异步chunk，在构建依赖图时标记为需要单独打包

**共享块**

当多个chunk依赖同一个模块时，rollup会自动提取其为公共chunk；有时候也不一定会单独提成一个chunk，而是放到某个chunk中，其他chunk通过跨chunk引用共享改模块

![image-20251002212829174](打包优化.assets/image-20251002212829174.png)

## 手动代码拆分，自定义chunk

### manualChunks配置

函数形式

```ts
manualChunks: (id: string, { getModuleInfo, getModuleIds }) => {
    // 参数id为模块的绝对路径，getModuleInfo获取模块详细信息，getModuleIds获取所有模块ID
    模块详细信息包括如下
    id: moduleInfo.id,
    importers: moduleInfo.importers,      // 谁导入了这个模块
    dynamicImporters: moduleInfo.dynamicImporters,  // 动态导入
    importedIds: moduleInfo.importedIds,  // 该模块导入了谁
    isEntry: moduleInfo.isEntry,          // 是否是入口
    code: moduleInfo.code                 // 模块代码
}
```

每个模块都会运行一次该函数，函数返回值为chunk名称(string或undefined)。返回string该模块会被分配到指定的chunk，返回undefined采用默认分割策略。入口文件及其直接依赖不受手动分包返回值的影响，打包到入口chunk中。

对象形式

```ts
manualChunks: {
    'vendor': ['react', 'react-dom'],
    'utils': ['lodash', 'axios']
}
```

### 使用默认分割策略

打包结果如下，按照默认代码拆分规则形成多个chunk，导致形成多个js文件

**导致的问题：**

由于浏览器http1.1对同域名请求有限制（最多同时6-8个，超过6-8个后面的进行pending等待状态），chunk数量多形成的js文件多导致资源加载时间长

由于渲染树由dom树+cssom树构成，如果css下载被阻塞了，没有形成完整的cssom，浏览器无法确定元素的最终样式与布局，导致浏览器延迟渲染避免无样式内容闪烁而导致白屏

<img src="打包优化.assets/image-20251002214251436.png" alt="image-20251002214251436"  />

### vendor与index两个chunk

将node_modules第三方库（vue、vue-router、pinia、element-plus）放入vendor这个chunk中

将业务放入index这个chunk中

```js
output: {
    manualChunks: (id: string) => {
        if (id.includes('node_modules')) {
            return 'vendor'
        }
        return 'index'
    }
}
```

打包结果如下，两个js文件：index与vendor

![image-20251002214421299](打包优化.assets/image-20251002214421299.png)

**这种策略的问题：**

问题1：首屏时间过长，我们写的动态导入（例如使用路由懒加载）不会形成单独的chunk了，导致首屏时间过长（由于所有路由页面都打包到一个js中，所以在一开始路由对应的页面下也会去加载当前不会访问的页面）

问题2：资源无法更有效的缓存，每个chunk对应的打包后的文件的文件名都有一个哈希值，当我们只修改了其中一个页面的内容时会导致index对应的文件名的哈希值也会改变，使得浏览器不会复用之前的文件，重新去请求



### 最佳实践打包策略

#### 第三方包

1. 整个项目多个页面都依赖的第三方库放到一个包

2. 只有某个业务用到（极少数页面使用）的第三方库，每个库单独放到一个包或者使用外链cdn的形式不进行打包

**某个业务用到的第三方库，单独放到一个包**

例如，只有about页面用到了html2canvas，其他页面都没有用到html2canvas，那么我们可以将html2canvas打包放到一个包里，其他第三方模块放在vendor一个包里，业务代码放到index包里

![image-20251003142420980](打包优化.assets/image-20251003142420980.png)

配置如下

```js
output: {
    manualChunks: (id: string) => {
        // html2canvas库放在一个包里
        if (id.includes('html2canvas')) {
            return 'html2canvas'
        }
        // 除了html2canvas库外其他第三方库放在一个包里
        if (id.includes('node_modules')) {
            return 'vendor'
        }
        // 业务代码放在一个包里
        return 'index'
    }
}
```

打包结果如下

![image-20251003142457435](打包优化.assets/image-20251003142457435.png)



**外链cdn的形式，配置某些第三方库不进行打包，提高打包速度**

例如，只有about页面用到了html2canvas，其他页面都没有用到html2canvas，那么我们可以将html2canvas不打包使用外链cdn的形式，借助插件`rollup-plugin-external-globals`

![image-20251003142420980](打包优化.assets/image-20251003142420980.png)

配置如下

```js
import externalGlobals from 'rollup-plugin-external-globals'
const globals = externalGlobals({
    moment: 'moment',
    'video.js': 'video.js',
    jspdf: 'jspdf',
    xlsx: 'XLSX',
    echart: 'echart',
    html2canvas: 'html2canvas'
})

rollupOptions: {
    plugins: [
        globals
    ],
    // 不进行打包，以外链的实现处理
    external: ['moment', 'video.js', 'jspdf', 'XLSX', 'echart', "html2canvas"],
    output: {
        manualChunks: (id: string) => {
            if (id.includes('node_modules')) {
                return 'vendor'
            }
            return 'index'
        }
    }
}
```

index.html中放入cdn的script脚本

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>AIChat</title>
    </head>
    <body>
        <div id="app"></div>
        <script type="module" src="/src/main.ts"></script>
    </body>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</html>
```

打包结果如下

![image-20251003145739824](打包优化.assets/image-20251003145739824.png)



#### 业务代码

业务代码打包时，采用按需加载，每个页面放到一个包

#### 为什么你采取这样的分包策略，和面试官怎么聊

我们进行打包时如果不进行配置的化，默认会打包成很多个文件，而浏览器在http1.1下对单个域名tcp个数有限制，有的文件体积非常小不合适，所以我们就要进行合并

一种情况是有的第三方包只有某个页面使用我们要将其提出来，还有一种情况是我们的模块用到的第三方库特别多，我们就不进行打包，以cdn外链的形式，提升打包速度

此外交通项目其实首屏不会显示echarts图表的，如果不进行分包的话echarts库的文件会与业务放在一起，导致首屏加载的js文件内容大加载时间变长，所以将echarts图表单独打了一个包 或者 使用cdn外链的形式同时配置prefetch在浏览器空闲时提前加载资源，优化后续页面的加载时间

分包后点击某个页面某个模块时只要改模块需要的文件才会加载，其他不需要的文件不加载，切换页面再回来时，加载过的文件不再加载直接用原来的



## 配置打包文件目录结构

配置

```js
output: {
    chunkFileNames: 'static/js/[name]-[hash].js', // 代码分割后chunk的文件名
    entryFileNames: 'static/js/[name]-[hash:6].js', // 入口文件名，[hash:6]用于控制哈希值位数为6位
    assetFileNames: 'static/[ext]/[name]-[hash].[ext]' // 静态资源文件名
}
```

打包后的结果，js放入了js文件夹中，css等其他后缀文件放入自己后缀文件夹中，相比于不配置所以文件全部放在dist的static中这样更加清晰

![image-20251003153120867](打包优化.assets/image-20251003153120867.png)



## 使vite拥有和webpack一样的一些配置

例如webpack支持如下路由配置，通过/* webpackChunkName: "xxx" */注解的方式将多个动态懒加载的路由合并到同一个xxx的chunk中，但是vite是不支持这种配置的，通过查询[rollup上的issue](https://github.com/rollup/rollup/issues/4283)解决

```js
export default {
    path: '/',
    name: 'Home',
    component: () => import(/* webpackChunkName: "home" */ '@/layout/index.vue'),
    children: [
        {
            path: '/',
            name: 'HomePage',
            component: () => import(/* webpackChunkName: "home" */ '@/views/home/index.vue'),
        },
        {
            path: '/user',
            name: 'UserPage',
            component: () => import(/* webpackChunkName: "user" */ '@/views/user/index.vue'),
        },
        {
            path: '/role',
            name: 'RolePage',
            component: () => import(/* webpackChunkName: "role" */ '@/views/role/index.vue'),
        },
        {
            path: '/auth',
            name: 'AuthPage',
            component: () => import(/* webpackChunkName: "auth" */ '@/views/auth/index.vue'),
        }
    ]
};

```



# 查看打包结果的可视化插件

rollup-plugin-visualizer

```js
import {visualizer} from 'rollup-plugin-visualizer'

export default defineConfig(() => {
    return {
        plugins: [
            // 可视化查看rollup模块依赖关系
            visualizer()
        ],
});
```

当npm run build时会将依赖图形成一个stats.html文件



# 文件压缩机制-gzip/br

传统B/S中的压缩传输，缺点是服务器的压缩需要时间，客户端的解压需要时间

![](构建工具性能优化.assets/2020-02-28-15-37-26.png)

使用打包工具直接对打包结果进行预压缩，移除服务器的压缩时间

![](构建工具性能优化.assets/2020-02-28-15-41-44.png)

通过网络面板的响应头的Content-Encoding字段，可知当前请求的文件的编码格式

![image-20251003152117959](打包优化.assets/image-20251003152117959.png)

### gzip

使用插件`vite-plugin-compression`

配置

```js
import ViteCompression from 'vite-plugin-compression'
plugins:[
    ViteCompression({
    	threshold:1024*20, // 超过20kb才进行压缩
     	ext:'.gz', // 压缩后缀
     	algorithm:'gzip' // 压缩算法
    }),
]
```

### br

br比gzip有更好的压缩比（使包更小），使用插件`rollup-plugin-brotli`

```js
import brotli from 'rollup-plugin-brotli'
plugins:[
    brotli({})
]
```



# 分包的目的

分包的目的是**提取大量的公共代码**，从而减少总体积、充分利用浏览器缓存

当公共代码已经被提取分包后，虽然还可以配置将一些包进行再切分，但是实际的总体积和传输量并没有发生变。如果要进一步减少公共模块的体积，只能是压缩和`tree shaking`



# manifest.json文件

manifest.json是一个构建产物清单文件，记录了「每个输入模块」和「它在最终打包输出中对应的文件」之间的映射关系。

每个元素就是一个要打包的产物文件，如果是js产物则对应一个chunk。每个元素的key可能有两类

**用源码路径当key（key就是文件在源码中的文件路径）的元素**，这个产物是由一个门面模块产出，这类产物来源是懒加载的页面组件、动态引入的工具包、入口文件

**用`_+chunk名`当key的元素**，这类元素是打包器为了去重/复用，将多个入口/页面的共同依赖抽成，这类产物来源是共享chunk、 `manualChunks` 里自定义chunk。



# vite插件

插件就是一个对象，对象上有若干属性（name等）和钩子函数。通常我们将插件写为一个工厂函数（接收配置参数，这样用户可以配置插件的行为），然后返回这个插件对象

**插件上下文（`this`）**
`this.emitFile`（生成额外文件、资源）

`this.addWatchFile`（在 watch 模式下监听某些文件变化）

`this.error` / `this.warn`（报错警告）

## 常用钩子

插件可以利用钩子在打包构建过程中钩入某些阶段，做一些自定义操作，如修改源码、生成额外文件等

以下为rollup常用钩子

| 钩子名                                     | 什么时候触发 / 用途                                       | 返回值 / 必要性                                              |
| ------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ |
| `options`                                  | 读取配置                                                  | 修改最终的 rollup 配置                                       |
| `buildStart`                               | 构建开始前                                                | 做一些初始化、检查等操作                                     |
| `resolveId(source, importer)`              | 模块解析阶段判断某个 `import` 的路径                      | 如果返回一个字符串，就表示这个模块由本插件接管，不再继续默认解析 |
| `load(id)`                                 | 某个模块被 “resolve” 后，决定如何 “加载” 它               | 返回 `{ code, map }` 或字符串等                              |
| `transform(code, id)`                      | 对模块代码做转换（例如 Babel、TS 转换、替换、插入代码等） | 返回 `{ code, map }` 或 `null`（表示不处理）                 |
| `generateBundle(options, bundle, isWrite)` | 在最终打包生成阶段，可以插入、修改、删除 bundle 中的资源  | 无返回或返回一些修改                                         |
| `writeBundle`                              | 在 bundle 写入磁盘之后                                    | 通常做一些后处理（比如上传、复制等）                         |

Vite 在 Rollup 钩子之外额外提供：

- `configureServer(server)`：可以获取开发服务器实例，做一些中间件、HTTP 拦截、热更新等操作
- `transformIndexHtml`：专门用来处理 HTML 模板、插入 script / meta / link 等标签的钩子
- `handleHotUpdate`：热模块替换（HMR）更新时拦截、处理变更



# Terser

Terser是js压缩、混淆和优化的工具，支持ES6（之前使用的都是UglifyJs，但是其不支持ES6而淘汰），通过以下方式优化js代码：

1. 代码压缩：删除空格、注释、换行等冗余字符
2. 混淆处理：重命名变量和函数为短名称

**Terser与gzip/br的区别**

terser是代码压缩，作用于js代码上，移除冗余代码、缩短标识符

gzip/br是传输压缩，对任意文件内容压缩，减少网络传输体积

