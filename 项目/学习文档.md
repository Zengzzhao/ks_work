# Vue高级API

## effectScope

批量管理副作用，在适当的时机统一清理

## defineModel





# VueUse

## 最佳实践

返回一个对象，使用者通过对象解构提取所需内容

副作用清理：自动清理副作用，如果需要手动释放副作用则返回一个停止函数stop

## useRequest

[文档](https://mahoushoujoarale.github.io/vue-useRequest-docs/)

```ts
const {
    loading: detailLoading,
    error: detailErrorRef,
    run: runGetModelDetail,
    cancel: cancelGetModelDetail,
} = useRequest(getModelDetailService, {
    onSuccess: resp => {
        const modelDetailData = resp.data;
        // 判断是否展示 Claude 提醒
        showClaudAlert.value = modelDetailData.vendorName === 'Anthropic';
        document.title = `模型详情-万擎-${modelDetailData.name}`;
        modelInfoFromApi.value = modelDetailData;
        if (modelDetailData?.modelFamily) {
            runGetFamilyModels({ modelFamily: modelDetailData.modelFamily });
        } else {
            familyModelsResponseData.value = { total: 0, list: [] };
        }
    },
    onError: e => {
        ElMessage.error(e.message || '加载模型详情时发生网络错误');
        familyModelsResponseData.value = { total: 0, list: [] };
    },
});
```

# 项目打包器

baidi->rspack



# git

## ssh、https与git config的name与email区别

ssh和https是两种连接和认证到远程仓库的方法

设置git config的user.name与user.email用来标记每次代码提交commit

## 命令

git pull：在A分支上执行git pull会1.更新当前分支为远程最新代码；2.获取所有分支的最新信息（但不会将其他分支更新到最新代码，其他分支要更新必须切换到对应分支后再pull更新）

## Merge Request(MR)

将其他开发分支合并入主分支master。创建好从A到master的MR后，如果审核人评论让你修改，你在A上进行的修改然后push后审核人能看到当前分支的最新修改代码，等到审核通过后就可以合并



# 环境

prod：业务线上环境，真正承载用户流量的环境

staging：预上线环境

测试环境：用于联调测试

dev：本地开发环境



# 各个平台功能

天穹：前端代码审查

破晓：无头浏览器

KDev：对标gitlab的代码仓库



# Tiptap

基于ProseMirror的无头富文本编辑器框架

编辑器分层架构，插件化开发

## 结构

### Schema

编辑器的语法规则。定义了文档运行哪种结构；可以有哪些node、mark节点；可以有哪些属性；哪些节点可以包含哪些子节点；哪些标记可以出现在哪些节点上

### Node

文档树的结构性元素。例如 `doc`、`paragraph`、`text`。通常决定文档的树形结构与布局。

### Mark

附着在text文本节点上的属性/装饰，如 `bold`、`italic`、`link`、`code`、`underline`。mark不改变文档树的结构（不是单独的树节点），而是附在text节点上并且一个text节点上可以有多个mark相互重叠。

## 扩展

### 常用钩子






# vue的作用域控制

## scoped

给组件style标签加上scoped后，vue会给当前组件每个元素加上一个唯一的数据属性data-v-xxx实现样式隔离，我们在style中写的常规的不加深度选择器的样式最终转换如下，使得父组件中写的样式无法直接选中子组件内部的元素

> 子组件最外层容器同时拥有父组件的数据属性、子组件自身的数据属性，所以父组件可以选中子组件最外层容器

```css
.test{
  color:red
}
--->转换后
.test[data-v-c815ea7e]{
  color:red;
}
```

## :deep()深度选择器

使用了深度选择器的样式最终转换如下，原理是重组CSS选择器，将唯一数据属性前移到目标选择器前，从而可以选中对应元素

```css
:deep(.test){
  color:red
}
--->转换后
[data-v-c815ea7e] .test{
  color:red;
}
```

常用于修改第三方组件样式

## :global()全局选择器

定义全局样式，不加上当前组件的作用域数据属性，对整个应用中所有匹配到的元素都生效

```css
:global(.test){
  color:red
}
--->转换后
.test{
  color:red
}
```

常用于修改一些被渲染到 `<body>`根节点下的组件（如使用 `Teleport`的弹窗、消息提示等），由于其不在当前组件树内，使用 `:deep()`可能无效，此时需要使用 `:global`
