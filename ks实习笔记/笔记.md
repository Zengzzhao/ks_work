# Vue高级API

## effectScope

批量管理副作用，在适当的时机统一清理

## defineModel



# Vue的样式作用域控制

## scoped

给组件style标签加上scoped后，vue会给当前组件每个元素加上一个唯一的数据属性data-v-xxx实现样式隔离，我们在style中写的常规的不加深度选择器的样式最终转换如下，使得父组件中写的样式无法直接选中子组件内部的元素

> 子组件最外层容器同时拥有父组件的数据属性、子组件自身的数据属性，所以父组件可以选中子组件最外层容器

```css
.test{
  color:red
}
--->转换后
.test[data-v-c815ea7e]{
  color:red;
}
```

## :deep()深度选择器

使用了深度选择器的样式最终转换如下，原理是重组CSS选择器，将唯一数据属性前移到目标选择器前，从而可以选中对应元素

```css
:deep(.test){
  color:red
}
--->转换后
[data-v-c815ea7e] .test{
  color:red;
}
```

常用于修改第三方组件样式

## :global()全局选择器

定义全局样式，不加上当前组件的作用域数据属性，对整个应用中所有匹配到的元素都生效

```css
:global(.test){
  color:red
}
--->转换后
.test{
  color:red
}
```

常用于修改一些被渲染到 `<body>`根节点下的组件（如使用 `Teleport`的弹窗、消息提示等），由于其不在当前组件树内，使用 `:deep()`可能无效，此时需要使用 `:global`



# VueUse

## 最佳实践

返回一个对象，使用者通过对象解构提取所需内容

副作用清理：自动清理副作用，如果需要手动释放副作用则返回一个停止函数stop

## useRequest

[文档](https://mahoushoujoarale.github.io/vue-useRequest-docs/)

```ts
const {
    loading: detailLoading,
    error: detailErrorRef,
    run: runGetModelDetail,
    cancel: cancelGetModelDetail,
} = useRequest(getModelDetailService, {
    onSuccess: resp => {
        const modelDetailData = resp.data;
        // 判断是否展示 Claude 提醒
        showClaudAlert.value = modelDetailData.vendorName === 'Anthropic';
        document.title = `模型详情-万擎-${modelDetailData.name}`;
        modelInfoFromApi.value = modelDetailData;
        if (modelDetailData?.modelFamily) {
            runGetFamilyModels({ modelFamily: modelDetailData.modelFamily });
        } else {
            familyModelsResponseData.value = { total: 0, list: [] };
        }
    },
    onError: e => {
        ElMessage.error(e.message || '加载模型详情时发生网络错误');
        familyModelsResponseData.value = { total: 0, list: [] };
    },
});
```

# 项目打包器

baidi->rspack



# git

## ssh、https与git config的name与email区别

ssh和https是两种连接和认证到远程仓库的方法

设置git config的user.name与user.email用来标记每次代码提交commit

## 命令

git pull：在A分支上执行git pull会1.更新当前分支为远程最新代码；2.获取所有分支的最新信息（但不会将其他分支更新到最新代码，其他分支要更新必须切换到对应分支后再pull更新）

## Merge Request(MR)

将其他开发分支合并入主分支master。创建好从A到master的MR后，如果审核人评论让你修改，你在A上进行的修改然后push后审核人能看到当前分支的最新修改代码，等到审核通过后就可以合并



# 环境

prod：业务线上环境，真正承载用户流量的环境

staging：预上线环境

测试环境：用于联调测试

dev：本地开发环境



# 各个平台功能

天穹：前端代码审查

破晓：无头浏览器

KDev：对标gitlab的代码仓库



# ProseMirror

基于Schema（结构文档模型）+ Transaction（事务）+ State（状态）+ Plugins（插件）的富文本编辑框架。

ProseMirror不是操作HTML的dom元素，而是操作一个类似Json、AST的树形文档结构。为了在浏览器中呈现编辑器内容需要将文档结构转换为dom元素，为了保存编辑内容需要将dom元素转换为文档结构

## 核心组成

Schema：编辑器的语法规则。定义文档内容结构

Node：文档中的某个内容元素。例如 `doc`、`paragraph`、`text`。

Mark：附着在text文本节点上的样式，如 `bold`、`italic`、`underline`。

State：文档存储在state中，所有对编辑器的操作都通过transaction应用到state上。state包含了当前文档doc、当前光标选区selection、当前激活的标记storedMarks、插件状态pluginStates

Transaction：所有对编辑器的操作都必须通过Transaction完成，提交Transaction生成一个新的state更新视图

Plugin：提供了props（提供钩子，拦截dom事件）、state（插件自己的state）、view（视图生命周期）

Decoration：不属于schema，仅用于UI显示

InputRules：输入规则

EditorView：渲染文档结构为真实dom

**tiptap的ProseMirror插件的例子**

```ts
// 输入左{补全右}
import { Extension } from '@tiptap/core';
import { Plugin, TextSelection } from '@tiptap/pm/state';

export const AutoBraces = Extension.create({
    name: 'autoBraces',

    // ProseMirror插件
    addProseMirrorPlugins() {
        return [
            new Plugin({
                props: {
                    // 拦截文本输入事件，用户输入任意文本时触发该钩子
                    // 输入左{补全右}
                    /**
                     * @param view 编辑器实例，可用于dispatch新事务
                     * @param from 编辑操作开始的位置
                     * @param to 编辑操作结束的位置
                     * @param text 用户输入的实际文本
                     * @return 是否处理了该输入事件,返回true表示已处理编辑器不再进行默认处理,返回false表示不处理继续默认行为
                     */
                    handleTextInput: (view, from, to, text) => {
                        if (text !== '{') return false;

                        const { state } = view;
                        let tr = state.tr.insertText('{}', from, to); // 在当前输入的光标处插入{}
                        tr = tr.setSelection(TextSelection.create(tr.doc, from + 1)); // 把光标移动到{}中间
                        view.dispatch(tr.scrollIntoView()); // 执行事务，更新视图
                        return true;
                    },
                },
            }),
        ];
    },
});

```



# Tiptap

基于ProseMirror的无头（不提供样式）富文本编辑器框架。tiptap的所有功能都通过extension组成，tiptap将每个extension解析成prosemirror构件

## Command

底层创建一个transaction，改变编辑器状态（内容、选区等）

### 使用command的两种方式

**直接调用**

```ts
editor.commands.xxx()
// 每次只能执行一个command，使用后立即执行
```

**链式调用**

```ts
editor.chain().xxx1().xxx2().xxx3().run()
```

`.chain()`创建一个command队列，将xxx1()、xxx2()、xxx3()依次加入到队列中，`.run()`时才会依次执行队列中所有command

## InputRule



## Extension

tiptap所有功能通过extension实现

### 常用钩子

| 钩子名                    | 作用             | 典型场景                              |
| ------------------------- | ---------------- | ------------------------------------- |
| `name`                    | 声明扩展名称     | 唯一标识                              |
| `addOptions()`            | 设置默认配置     | 可通过 `editor.extensionManager` 访问 |
| `addAttributes()`         | 定义属性         | 自定义标记样式或数据                  |
| `parseHTML()`             | HTML → Doc       | 解析外部内容（setContent、paste）     |
| `renderHTML()`            | Doc → HTML       | 导出 HTML 时使用                      |
| `addCommands()`           | 注册命令         | 可通过 `editor.commands.xxx()` 调用   |
| `addInputRules()`         | 定义输入触发规则 | 自动转换输入（如 `**bold**`）         |
| `addPasteRules()`         | 定义粘贴触发规则 | 粘贴内容自动格式化                    |
| `addKeyboardShortcuts()`  | 定义快捷键       | 如 `Cmd+B` 加粗                       |
| `addProseMirrorPlugins()` | 注入原生 PM 插件 | 高级行为定制                          |



